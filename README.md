Программа получилась далека от желаемой производительности благодаря огромному оверхеду,
накладываемому перловым рантаймом на вызов подпрограмм.
Как можно ускорить? В случае с парсер комбинаторами - почти никак, разве что вынести вычисление арифм. выражений
в блоках в отдельный процесс/тред (fork/join).
Или же реализовать разбор на уровне xsub, что сведет на нет преимущества динамизма перлового рантайма,
так как это эквивалентно написание парсера на любом другом языке с оптимизирующим компилятором.
Единственная надежда, остаться в перле и добиться высокой производительности программы - регекспы.
Можно и в комбинатором стиле - https://metacpan.org/pod/distribution/Pegex/lib/Pegex.pod

Если бы перл делал вызов сабы за хотя бы 5-10нс (как встроенный опкод) , то текущая реализация была бы продакшен-ready.
Но перл оптимизирует (инлайнит) только сабы с протопипом () и без внешних ссылок внутри блока сабы, что эквивалентно константе.
Все остальные случаи (@_=(...),&foo; $foo->(@args); @_(...);goto &foo) очень медленные.
Поэтому парсинг на перле - это только регекспы/(Regexp::Grammar perl6 style)/Pegex или xsub.


Формат входных данных определен следующими условиями:
 Входной файл представляет собой набор блоков.
 Блок определен операторами START и END, которые определяют начало и конец блока 
соответственно, и содержит набор заданий для вычисления, разделенных между собой 
точкой с запятой.
 Оператор выделен пятью дефисами до и после.
 Задание начинается с названия уникальной для этого блока переменной, а дальше, после 
знака присвоения «:=», следует простое математическое выражение.
 Математическое выражение может содержать операторы сложения «+», вычитания «-», 
умножения «x», и деления «:». Все операнды в таких выражениях представляют собой 
численные значения. Кроме того возможно использование скобок.
Пример блока входных данных:
-----START <Block Name> ----- Var1:=(324,456 + 896,942.31 :92.54) * 1:2;
Var2 := 894783456.21+20:-2----- END <Block Name>-----
Задание:
1. Написать программу для вычисления результатов заданий с использованием языка perl.
2. Входные данные можно получить функцией Foo::GetDataChunk() из абстрактной внешней 
библиотеки. Функция вернет ссылку на строковый скаляр с куском входных данных. Размер 
куска никак не контроллируется и может занимать до 500Мб, хотя это и маловероятно...
3. Входные данные генерируются неизвестным внешним источником, потому могут содержать 
опечатки, ошибки или даже code injection, помните об этом 
4. Результат выполнения программы должен быть выведен в алфавитном порядке, по одной 
записи на строку, каждая строка результата имеет следующий формат: Section.Variable = Value;
5. Вы можете использовать файл small.dat для проверки работы своей программы
